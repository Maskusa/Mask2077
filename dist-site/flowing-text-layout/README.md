Ниже представлен гайд по созданию похожего сайта, основанный на анализе предоставленного кода.
Гайд по созданию движка верстки текста на React
Этот проект представляет собой React-приложение, использующее TypeScript и Tailwind CSS для создания динамического макета, в котором текст перетекает по страницам или колонкам. Основная идея — не разбивать текст на части в коде, а позволить CSS-движку браузера самому рассчитать разбивку, а затем измерить результат и управлять "окном просмотра" с помощью JavaScript.
Давайте разберем ключевые аспекты реализации.
1. Как считывается и устанавливается текст
Реализация этого шага проста и эффективна:
Хранение контента: Весь текст хранится в виде одной большой строки с HTML-тегами (<h1>, <p>, <strong> и т.д.) в отдельном файле (constants.ts). Это позволяет отделить контент от логики отображения.
Вставка в DOM: В React-компоненте (App.tsx) этот текст импортируется и вставляется в div с помощью атрибута dangerouslySetInnerHTML. Это необходимо, потому что контент содержит HTML-разметку, которую нужно отрисовать, а не отображать как обычный текст.
Важно: Использование dangerouslySetInnerHTML безопасно только тогда, когда вы полностью доверяете источнику контента (как в данном случае, где он является статической частью приложения). В противном случае это может создать уязвимость для XSS-атак.
Стилизация текста: Для стилизации текста используется плагин @tailwindcss/typography. Добавление класса prose к контейнеру автоматически применяет красивые и согласованные стили для заголовков, параграфов, списков и т.д., что идеально подходит для статей или книг.
2. Как создаются и заполняются страницы (пагинация)
Это самая сложная и интересная часть. В App.tsx "страницы" — это не отдельные элементы, а иллюзия, созданная с помощью CSS и JavaScript.
CSS Multi-column Layout: Основная технология — это многоколоночная верстка CSS.
Создается один-единственный контейнер для всего текста (textContainerRef).
Ему задается фиксированная высота (height), равная высоте "страницы", и свойство column-width, равное ширине "страницы".
Свойство column-fill: 'auto' заставляет браузер заполнять колонки последовательно, одну за другой, а не пытаться равномерно распределить текст по высоте.
В результате браузер сам выстраивает весь текст в длинную "ленту" из колонок.
"Окно просмотра" (Viewport):
Контейнер с колонками помещается внутрь другого div (родительского), у которого задана ширина одной колонки и overflow: hidden. Этот родительский div и есть наше "окно", через которое мы видим только одну страницу за раз.
Измерение и расчет страниц:
Здесь ключевую роль играет хук useLayoutEffect. Он выполняется после того, как DOM был обновлен, но до того, как браузер отрисовал изменения. Это идеальный момент для измерений.
Внутри useLayoutEffect мы измеряем scrollWidth контейнера с колонками. Это свойство дает нам общую ширину всей "ленты" колонок.
Зная общую ширину и ширину одной страницы (ширина колонки + column-gap), мы можем легко вычислить общее количество страниц (totalPages).
setTotalPages(Math.ceil(totalContentWidth / pageShiftWidth))
Эти значения сохраняются в состоянии (state) компонента.
3. Как реализована анимация и клики
Обработка кликов:
На кнопки "Next" и "Previous" повешены обычные обработчики onClick.
Эти функции (handlePrevPage, handleNextPage) изменяют состояние currentPage, увеличивая или уменьшая его на единицу. Внутри есть проверки, чтобы не выйти за пределы диапазона [0, totalPages - 1].
Анимация перелистывания:
Анимация полностью реализована на CSS. Контейнеру с колонками задан класс transition-transform, который указывает браузеру плавно анимировать любые изменения свойства transform.
Стиль transform динамически вычисляется на основе текущей страницы: transform: translateX(-${currentPage * pageShiftWidth}px).
Когда currentPage меняется, React перерисовывает компонент с новым значением transform. Вместо мгновенного скачка браузер, благодаря transition, плавно сдвигает контейнер, создавая эффект перелистывания.
4. Особенности настройки стиля и переноса строк
Динамические стили: В приложении используется интересный прием для управления стилями, которые зависят от состояния (например, headerMarginTop). Вместо того чтобы пытаться применить их через inline-стили (что не всегда возможно для сложных селекторов), компонент рендерит тег <style> прямо в DOM. Это позволяет создавать любые CSS-правила на лету, используя значения из состояния React.
code
Jsx
<style>{`
  .prose.dynamic-header-margins > * + h2 { 
    margin-top: ${headerMarginTop * 1.33}rem; 
  }
`}</style>
Контроль переносов (Widows and Orphans):
Чтобы избежать "висячих строк" (когда одна строка параграфа остается в конце одной колонки или в начале следующей), используются CSS-свойства orphans и widows.
Классы [&>*]:orphans-1 и [&>*]:widows-1 применяются к контейнеру с текстом. Они говорят браузеру, что у начала (widows) и конца (orphans) параграфа на границе колонки должна быть как минимум 1 строка. Обычно для лучшей типографики ставят значение 2 или 3.
Свойство break-inside: auto (через класс [&>*]:[break-inside:auto]) предотвращает разрыв элементов (например, заголовков или изображений) между колонками.